[{"name":"Promise","comment":"\n\n\n## A Promise type for managing asynchronous effects in Elm\n\n@docs Promise\n\n\n## Create promises\n\n@docs fromValue, fromError, fromResult, fromState\n\n@docs fromModel, fromUpdate, fromEffectWhenEmpty\n\n\n## Map and chain promises\n\n@docs map, andThen, andMap, map2, map3, map4, combine\n\n\n## Transform effect, errors, and states\n\n@docs mapEffect, mapError\n\n\n## Extract\n\n@docs withMaybe, withMaybeWhenError, withResult, withState\n\n\n## Handle specific states\n\n@docs whenPending, whenError, recover\n\n\n## Working with the Model\n\n@docs embedModel\n\n\n## Run updates when a promise resolves\n\n@docs update, runWith, run\n\n","unions":[{"name":"Promise","comment":" ","args":["model","effect","e","a"],"cases":[]}],"aliases":[],"values":[{"name":"andMap","comment":" ","type":"Promise.Promise model effect e a -> Promise.Promise model effect e (a -> b) -> Promise.Promise model effect e b"},{"name":"andThen","comment":" ","type":"(a -> Promise.Promise model effect e b) -> Promise.Promise model effect e a -> Promise.Promise model effect e b"},{"name":"combine","comment":" ","type":"List.List (Promise.Promise model effect e a) -> Promise.Promise model effect e (List.List a)"},{"name":"embedModel","comment":" Use with promises for nested models\n","type":"(outerModel -> innerModel) -> (innerModel -> outerModel -> outerModel) -> Promise.Promise innerModel effect e a -> Promise.Promise outerModel effect e a"},{"name":"fromEffectWhenEmpty","comment":" Create a `Promise` based on values that are fetched via effects.\n\nThe effect could be anything like HTTP requests, ports, etc.\n\nIn this example, the effect is an HTTP request and it will only\nbe performed if the current state is `Empty` or `Stale`.\n\n    type Msg\n        = GotUser (Result Http.Error User)\n        | OtherMessages\n\n    getUser : Promise User\n    getUser =\n        Http.get\n            { url = \"/user\"\n            , expect =\n                Http.expectJson\n                    GotUser\n                    userDecoder\n            }\n            |> Promise.fromValue\n            |> Promise.fromEffectWhenEmpty\n            |> Promise.embedModel\n                .user\n                (\\state model ->\n                    { model | user = state }\n                )\n\n","type":"Promise.Promise (Promise.State.State err a) effect err effect -> Promise.Promise (Promise.State.State err a) effect err a"},{"name":"fromError","comment":" ","type":"e -> Promise.Promise model effect e a"},{"name":"fromModel","comment":" \"Read\" the `Model` to create a `Promise`.\n\nFor example when you need values from `Flags`.\n\n","type":"(model -> Promise.Promise model effect e a) -> Promise.Promise model effect e a"},{"name":"fromResult","comment":" ","type":"Result.Result e a -> Promise.Promise model effect e a"},{"name":"fromState","comment":" ","type":"Promise.State.State e a -> Promise.Promise model effect e a"},{"name":"fromUpdate","comment":" Create a `Promise` based on the `Model`. Also allows you to update the `Model`.\n\nUseful when you want to cache an expensive computation in the `Model`.\n\n    parseSource : String -> Result Parser.Error AST\n    parseSource source =\n        -- expensive parsing logic here\n        ...\n\n    cachedAst : String -> Promise Model effect Parser.Error AST\n    cachedAst source =\n        fromUpdate\n            (\\model ->\n                case Dict.get source model.astCache of\n                    Just result ->\n                        ( model\n                        , Promise.fromResult result\n                        )\n\n                    Nothing ->\n                        let\n                            result =\n                                parseSource source\n                        in\n                        ( { model\n                            | astCache =\n                                Dict.insert source\n                                    result\n                                    model.astCache\n                          }\n                        , Promise.fromResult result\n                        )\n            )\n\n","type":"(model -> ( model, Promise.Promise model effect e a )) -> Promise.Promise model effect e a"},{"name":"fromValue","comment":" ","type":"a -> Promise.Promise model effect e a"},{"name":"map","comment":" ","type":"(a -> b) -> Promise.Promise model effect e a -> Promise.Promise model effect e b"},{"name":"map2","comment":" ","type":"(a -> b -> c) -> Promise.Promise model effect e a -> Promise.Promise model effect e b -> Promise.Promise model effect e c"},{"name":"map3","comment":" ","type":"(a -> b -> c -> d) -> Promise.Promise model effect e a -> Promise.Promise model effect e b -> Promise.Promise model effect e c -> Promise.Promise model effect e d"},{"name":"map4","comment":" ","type":"(a -> b -> c -> d -> e) -> Promise.Promise model effect err a -> Promise.Promise model effect err b -> Promise.Promise model effect err c -> Promise.Promise model effect err d -> Promise.Promise model effect err e"},{"name":"mapEffect","comment":" ","type":"(effect1 -> effect2) -> Promise.Promise model effect1 e a -> Promise.Promise model effect2 e a"},{"name":"mapError","comment":" ","type":"(e1 -> e2) -> Promise.Promise model effect e1 a -> Promise.Promise model effect e2 a"},{"name":"recover","comment":" ","type":"(e -> Promise.Promise model effect x a) -> Promise.Promise model effect e a -> Promise.Promise model effect x a"},{"name":"run","comment":" ","type":"Promise.Promise model effect Basics.Never () -> model -> ( model, List.List effect )"},{"name":"runWith","comment":" ","type":"model -> Promise.Promise model effect Basics.Never () -> ( model, List.List effect )"},{"name":"update","comment":" ","type":"(Promise.State.State e a -> model -> ( model, List.List effect )) -> Promise.Promise model effect e a -> Promise.Promise model effect Basics.Never ()"},{"name":"whenError","comment":" ","type":"(e -> a) -> Promise.Promise model effect e a -> Promise.Promise model effect xx a"},{"name":"whenPending","comment":" ","type":"a -> Promise.Promise model effect e a -> Promise.Promise model effect e a"},{"name":"withMaybe","comment":" ","type":"Promise.Promise model effect e a -> Promise.Promise model effect xx (Maybe.Maybe a)"},{"name":"withMaybeWhenError","comment":" ","type":"(e -> Basics.Bool) -> Promise.Promise model effect e a -> Promise.Promise model effect e (Maybe.Maybe a)"},{"name":"withResult","comment":" ","type":"Promise.Promise model effect e a -> Promise.Promise model effect xx (Result.Result e a)"},{"name":"withState","comment":" ","type":"Promise.Promise model effect e a -> Promise.Promise model effect xx (Promise.State.State e a)"}],"binops":[]},{"name":"Promise.Queue","comment":"\n\n@docs Queue, RequestId\n\n@docs empty, add, remove, insert\n\n@docs requests, any, all\n\n@docs run, Group, send, withGroup, skip\n\n","unions":[{"name":"Group","comment":" ","args":["request","effect"],"cases":[]},{"name":"Queue","comment":" ","args":["reqest"],"cases":[]},{"name":"RequestId","comment":" ","args":[],"cases":[["RequestId",["String.String"]]]}],"aliases":[],"values":[{"name":"add","comment":" ","type":"req -> Promise.Queue.Queue req -> Promise.Queue.Queue req"},{"name":"all","comment":" ","type":"(request -> Basics.Bool) -> Promise.Queue.Queue request -> Basics.Bool"},{"name":"any","comment":" ","type":"(request -> Basics.Bool) -> Promise.Queue.Queue request -> Basics.Bool"},{"name":"empty","comment":" ","type":"String.String -> Promise.Queue.Queue req"},{"name":"insert","comment":" ","type":"Promise.Queue.RequestId -> req -> Promise.Queue.Queue req -> Promise.Queue.Queue req"},{"name":"remove","comment":" ","type":"Promise.Queue.RequestId -> Promise.Queue.Queue req -> Promise.Queue.Queue req"},{"name":"requests","comment":" ","type":"Promise.Queue.Queue request -> List.List ( Promise.Queue.RequestId, request )"},{"name":"run","comment":" ","type":"(Promise.Queue.RequestId -> req -> Promise.Promise model eff err (Promise.Queue.Group req eff)) -> Promise.Queue.Queue req -> Promise.Promise model eff err ( Promise.Queue.Queue req, List.List eff )"},{"name":"send","comment":" ","type":"Promise.State.State err response -> Promise.Promise model eff err ( request, effect ) -> Promise.Promise model eff err (Promise.Queue.Group request effect)"},{"name":"skip","comment":" ","type":"Promise.Queue.Group request effect"},{"name":"withGroup","comment":" ","type":"String.String -> Promise.State.State err response -> Promise.Promise model eff err ( request, effect ) -> Promise.Promise model eff err (Promise.Queue.Group request effect)"}],"binops":[]},{"name":"Promise.State","comment":" States represent the lifecycle of an asynchronous value that is loaded through\n`Promise` helpers.\n\n@docs State\n\n\n## Creating states\n\n@docs fromMaybe, fromResult\n\n\n## Conversions\n\n@docs resolve, toMaybe, getError, toResult\n\n\n## Modify state\n\n@docs markStale, setPending, map\n\n\n## Check states\n\n@docs isEmpty, isPending, isStale, isDone, isError\n\n\n## JSON Encoding/Decoding\n\n@docs encode, decoder\n\n","unions":[{"name":"State","comment":" Track whether a value is loading, stale, finished, or has failed.\n\n\n## Explanation of states\n\n    Empty\n\nNo value has been requested yet\n\n    Pending Nothing\n\nState is loading, no value yet\n\n    Pending (Just \"old value\")\n\nState is reloading and we have an old value\n\n    Stale \"old value\"\n\nWe have a value, but it should be refreshed\n\n    Done \"fresh value\"\n\nWe have a fresh value\n\n    Error \"something went wrong\"\n\nThere was a problem loading the value\n\n","args":["e","a"],"cases":[["Empty",[]],["Pending",["Maybe.Maybe a"]],["Stale",["a"]],["Done",["a"]],["Error",["e"]]]}],"aliases":[],"values":[{"name":"decoder","comment":" Decode a state from JSON, given decoders for the error and value types.\n\n    JD.decodeString\n        (decoder JD.string JD.int)\n        \"\"\"{ \"tag\": \"Done\",\"value\": 5}\"\"\"\n        == Ok (Done 5)\n\n    JD.decodeString\n        (decoder JD.string JD.int)\n        \"\"\"{ \"tag\": \"Error\",\"value\": \"oops\"}\"\"\"\n        == Ok (Error \"oops\")\n\n","type":"Json.Decode.Decoder e -> Json.Decode.Decoder a -> Json.Decode.Decoder (Promise.State.State e a)"},{"name":"encode","comment":" Encode a state to JSON, given encoders for the error and value types.\n\n    encode JE.string JE.int (Done 5)\n        |> JE.encode 2\n        == \"\"\"{ \"tag\": \"Done\",\"value\": 5}\"\"\"\n\n\n\n","type":"(e -> Json.Encode.Value) -> (a -> Json.Encode.Value) -> Promise.State.State e a -> Json.Encode.Value"},{"name":"fromMaybe","comment":" Convert a `Maybe` into a state, keeping any existing payload.\n\n    fromMaybe (Just 10) == Done 10\n\n    fromMaybe Nothing == Empty\n\n","type":"Maybe.Maybe a -> Promise.State.State e a"},{"name":"fromResult","comment":" Convert a `Result` into a state, keeping successful payloads and failures.\n\n    fromResult (Ok 5) == Done 5\n\n","type":"Result.Result e a -> Promise.State.State e a"},{"name":"getError","comment":" Extract the error payload when the state is `Error`.\n\n    getError (Error \"timeout\") == Just \"timeout\"\n\n","type":"Promise.State.State e a -> Maybe.Maybe e"},{"name":"isDone","comment":" Tell whether the state contains a completed value.\n\n    isDone (Done 42) == True\n\n","type":"Promise.State.State e a -> Basics.Bool"},{"name":"isEmpty","comment":" Check if a state is empty, meaning no value has been requested yet.\n\n    isEmpty Empty == True\n\n","type":"Promise.State.State e a -> Basics.Bool"},{"name":"isError","comment":" Tell whether the state is an error.\n\n    isError (Error \"boom\") == True\n\n","type":"Promise.State.State e a -> Basics.Bool"},{"name":"isPending","comment":" Check if a state is currently pending.\n\n    isPending (Pending Nothing) == True\n\n    isPending (Pending (Just 1)) == True\n\n","type":"Promise.State.State e a -> Basics.Bool"},{"name":"isStale","comment":" Detect if the data is still usable but due for a refresh.\n\n    isStale (Stale 1) == True\n\n","type":"Promise.State.State e a -> Basics.Bool"},{"name":"map","comment":" Map state\n","type":"(a -> b) -> Promise.State.State e a -> Promise.State.State e b"},{"name":"markStale","comment":" Mark completed values as `Stale` to indicate they should be refreshed.\n\n    markStale (Done \"user\") == Stale \"user\"\n\n","type":"Promise.State.State e a -> Promise.State.State e a"},{"name":"resolve","comment":" Handle all possible states by providing a value for each case.\n","type":"b -> (e -> b) -> (a -> b) -> Promise.State.State e a -> b"},{"name":"setPending","comment":" Set the state to `Pending`, keeping any existing value as a `Maybe`.\n\n    setPending (Done 5) == Pending (Just 5)\n\n","type":"Promise.State.State e a -> Promise.State.State e a"},{"name":"toMaybe","comment":" Extract any known value from the state.\n\n    toMaybe (Pending (Just 3)) == Just 3\n\n","type":"Promise.State.State e a -> Maybe.Maybe a"},{"name":"toResult","comment":" Turn a state into a `Result`.\n\nProvide a default `Result` to use when there is no value available.\n\n    toResult (Ok 1) (Done 42) == Ok 42\n\n    toResult (Ok 1) Empty == Ok 1\n\n    toResult (Ok 1) (Error \"Oh no!\") == Err \"Oh no!\"\n\n    toResult (Err \"No answer\") (Done 42) == Ok 42\n\n    toResult (Err \"No answer\") Empty == Err \"No answer\"\n\n    toResult (Err \"No answer\") (Error \"Oh no!\") == Err \"Oh no!\"\n\n","type":"Result.Result e a -> Promise.State.State e a -> Result.Result e a"}],"binops":[]}]